{"ast":null,"code":"var _jsxFileName = \"/Users/apple/Sites/jiffy/src/App.js\";\nimport React, { Component } from 'react'; //here we import in our loader spinner image\n\nimport loader from \"./images/loader.svg\";\nimport clearButton from \"./images/close-icon.svg\";\nimport Gif from './Gif';\n\nconst randomChoice = arr => {\n  const randIndex = Math.floor(Math.random() * arr.length);\n  return arr[randIndex];\n};\n\nconst Header = ({\n  clearSearch,\n  hasResults\n}) => /*#__PURE__*/React.createElement(\"div\", {\n  className: \"header grid\",\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 16,\n    columnNumber: 3\n  }\n}, hasResults ? /*#__PURE__*/React.createElement(\"button\", {\n  onClick: clearSearch,\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 19,\n    columnNumber: 7\n  }\n}, /*#__PURE__*/React.createElement(\"img\", {\n  src: clearButton,\n  alt: \"clear button\",\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 20,\n    columnNumber: 9\n  }\n})) : /*#__PURE__*/React.createElement(\"h1\", {\n  className: \"title\",\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 22,\n    columnNumber: 9\n  }\n}, \"Jiffy\"));\n\nconst UserHint = ({\n  loading,\n  hintText\n}) => /*#__PURE__*/React.createElement(\"div\", {\n  className: \"user-hint\",\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 27,\n    columnNumber: 3\n  }\n}, loading ? /*#__PURE__*/React.createElement(\"img\", {\n  src: require('./images/loader.svg'),\n  alt: \"loader\",\n  className: \"block mx-auto\",\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 31,\n    columnNumber: 3\n  }\n}) : hintText);\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n\n    this.searchGiphy = async searchTerm => {\n      this.setState({\n        //here we set our loading state to be true\n        //and this will show the spinner at the bottom\n        loading: true\n      }); // first we try our fetch\n\n      try {\n        // here we use the await key word to wait for our response to come back\n        const response = await fetch(`https://api.giphy.com/v1/gifs/search?api_key=JWfQkyED854JjZJOKiPMb6BZkrxpam10&q=${searchTerm}&limit=25&offset=0&rating=g&lang=en`); // here we convert our raw response into jason data \n        // const {data} gets the .data part of our responses\n\n        const {\n          data\n        } = await response.json(); // here we check if the array of results is empty\n        // if it is, we throw an error which will stop the\n        // code here and handle it in the catch area\n\n        if (!data.length) {\n          throw `Nothing found for ${searchTerm}`;\n        } // here we grab a random result from our images\n\n\n        const randomGif = randomChoice(data);\n        this.setState((prevState, props) => ({ ...prevState,\n          // get the first result and put it in the state\n          // gif: randomGif,\n          // here we use spread to take the previous gifs and spread them out\n          // and then, add our new random gif onto the end\n          gifs: [...prevState.gifs, randomGif],\n          //we turn off our loading spinner again\n          loading: false,\n          hintText: `Hit enter to see more ${searchTerm}`\n        })); // if our fetch fails we catch it down here\n      } catch (error) {\n        this.setState((prevState, props) => ({ ...prevState,\n          hintText: error,\n          loading: false\n        }));\n      }\n    };\n\n    this.handleChange = event => {\n      // const value = event.target.value\n      const {\n        value\n      } = event.target; // by setting the searcht term in our state\n      // and alos using that on the input as the value,\n      // we have created what is called a controlled input\n\n      this.setState((prevState, props) => ({ //we take our old props and spread them out here\n        ...prevState,\n        //and then we overwrite the ones we want after\n        searchTerm: value,\n        // we set the hint text when we have more than two characters\n        // in our input, otherwise we make it a empty string\n        hintText: value.length > 2 ? `Hit enter to search ${value}` : ''\n      }));\n    };\n\n    this.handleKeyPress = event => {\n      // when we have two or more characters in our search box\n      // and we have also pressed enter, we then want to run a search\n      // we can access a function called key\n      const {\n        value\n      } = event.target;\n\n      if (value.length > 2 && event.key === 'Enter') {\n        //here is where we run our search function\n        //here we call our searchGiphy function using the search term\n        this.searchGiphy(value);\n      }\n    };\n\n    this.clearSearch = () => {\n      this.setState((prevState, props) => ({ ...prevState,\n        searchTerm: '',\n        hintText: '',\n        gifs: []\n      }));\n    };\n\n    this.state = {\n      loading: false,\n      searchTerm: '',\n      hintText: '',\n      // gif: null,\n      // we have an array of gifs\n      gifs: []\n    };\n  } // we want a function that searches the giphy api using\n  // fetch and puts the search term into the query URL\n  // then we can do something with the results\n  // we can also write async methods into our components\n  // that let us use the async/await style of function\n\n\n  render() {\n    //const searchTerm = this.state.searchTerm\n    const {\n      searchTerm,\n      gifs\n    } = this.state; //here we set a variable to see if we have any gifs\n\n    const hasResults = gifs.length;\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: \"page\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 160,\n        columnNumber: 13\n      }\n    }, /*#__PURE__*/React.createElement(Header, {\n      clearSearch: this.clearSearch,\n      hasResults: hasResults,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 161,\n        columnNumber: 5\n      }\n    }), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"search grid\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 163,\n        columnNumber: 5\n      }\n    }, this.state.gifs.map(gif =>\n    /*#__PURE__*/\n    //  we spread out all our properties onto our Gif component\n    React.createElement(Gif, Object.assign({}, gif, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 171,\n        columnNumber: 8\n      }\n    }))), /*#__PURE__*/React.createElement(\"input\", {\n      className: \"input grid-item\",\n      placeholder: \"Type somethin\",\n      onChange: this.handleChange,\n      onKeyPress: this.handleKeyPress,\n      value: searchTerm,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 174,\n        columnNumber: 7\n      }\n    })), /*#__PURE__*/React.createElement(UserHint, Object.assign({}, this.state, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 181,\n        columnNumber: 5\n      }\n    })));\n  }\n\n}\n\nexport default App;","map":{"version":3,"sources":["/Users/apple/Sites/jiffy/src/App.js"],"names":["React","Component","Gif","randomChoice","arr","randIndex","Math","floor","random","length","Header","clearSearch","hasResults","clearButton","UserHint","loading","hintText","require","App","constructor","props","searchGiphy","searchTerm","setState","response","fetch","data","json","randomGif","prevState","gifs","error","handleChange","event","value","target","handleKeyPress","key","state","render","map","gif"],"mappings":"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","sourcesContent":["import React, {Component} from 'react';\n//here we import in our loader spinner image\nimport loader from './images/loader.svg';\n\nimport clearButton from './images/close-icon.svg';\n\nimport Gif from './Gif';\n\n\nconst randomChoice = arr => {\n  const randIndex = Math.floor(Math.random()* arr.length);\n  return arr[randIndex];\n};\n\nconst Header = ({clearSearch, hasResults}) => (\n  <div className=\"header grid\">\n    {/* if we have results, show the clear button, otherwise show the title */}\n    { hasResults ? (\n      <button onClick={clearSearch}>\n        <img src={clearButton} alt=\"clear button\" />\n      </button>\n    ) : <h1 className=\"title\">Jiffy</h1>}\n  </div>\n);\n\nconst UserHint = ({loading, hintText}) => (\n  <div className=\"user-hint\"> \n  {/* here we check whether we have a loading state and we render out\n  either our spinner or hintText based on that, using a ternary operator */}\n  {loading ? \n  <img src={require('./images/loader.svg')} alt=\"loader\" className=\"block mx-auto\" /> :\n    hintText\n  }</div>\n);\n\nclass App extends Component {\n\nconstructor(props) {\n  super(props) \n  this.state = {\n    loading: false,\n    searchTerm: '',\n    hintText: '',\n    // gif: null,\n    // we have an array of gifs\n    gifs: []\n  }\n}\n\n// we want a function that searches the giphy api using\n// fetch and puts the search term into the query URL\n// then we can do something with the results\n\n// we can also write async methods into our components\n// that let us use the async/await style of function\nsearchGiphy = async searchTerm => {\n\n  this.setState ({\n    //here we set our loading state to be true\n    //and this will show the spinner at the bottom\n    loading : true\n  });\n  // first we try our fetch\n  try {\n    // here we use the await key word to wait for our response to come back\n    const response = await fetch(\n      `https://api.giphy.com/v1/gifs/search?api_key=JWfQkyED854JjZJOKiPMb6BZkrxpam10&q=${searchTerm}&limit=25&offset=0&rating=g&lang=en`\n      ); \n    \n     // here we convert our raw response into jason data \n    // const {data} gets the .data part of our responses\n     const {data} = await response.json();\n\n\n    // here we check if the array of results is empty\n    // if it is, we throw an error which will stop the\n    // code here and handle it in the catch area\n\n    if (!data.length) {\n      throw `Nothing found for ${searchTerm}`\n    }\n\n\n      \n    // here we grab a random result from our images\n    const randomGif = randomChoice(data)\n\n\n    this.setState((prevState, props) => ({\n      ...prevState,\n      // get the first result and put it in the state\n      // gif: randomGif,\n      // here we use spread to take the previous gifs and spread them out\n      // and then, add our new random gif onto the end\n      gifs: [...prevState.gifs, randomGif ],\n      //we turn off our loading spinner again\n      loading: false, \n      hintText: `Hit enter to see more ${searchTerm}`\n    }))\n    \n    // if our fetch fails we catch it down here\n    } catch (error) {\n      this.setState((prevState, props) => ({\n        ...prevState,\n        hintText:error,\n        loading:false\n      }))\n    }\n  };\n\n  //with create react app we can write our methods as arrow\n  //functions, meaning we don't need the constructor and bind\n  handleChange = event => {\n    // const value = event.target.value\n    const {value} = event.target;\n    // by setting the searcht term in our state\n    // and alos using that on the input as the value,\n    // we have created what is called a controlled input\n    this.setState((prevState, props) => ({\n      //we take our old props and spread them out here\n      ...prevState,\n      //and then we overwrite the ones we want after\n      searchTerm: value,\n      // we set the hint text when we have more than two characters\n      // in our input, otherwise we make it a empty string\n      hintText: value.length > 2 ? `Hit enter to search ${value}` : ''\n    }));\n    \n   };\n    \n   handleKeyPress = event => {\n   // when we have two or more characters in our search box\n   // and we have also pressed enter, we then want to run a search\n   // we can access a function called key\n    const {value} = event.target;\n    if (value.length > 2 && event.key === 'Enter') {\n      //here is where we run our search function\n      //here we call our searchGiphy function using the search term\n      this.searchGiphy(value);\n    }\n   };\n\n   // here we reset our state by clearing every out and\n   // making it default again (like in our original state)\n   clearSearch = () => {\n     this.setState((prevState, props) => \n     ({\n       ...prevState,\n       searchTerm:'',\n       hintText: '',\n       gifs: []\n     }))\n   }\n\n   render() {\n     //const searchTerm = this.state.searchTerm\n     const { searchTerm, gifs } = this.state\n     //here we set a variable to see if we have any gifs\n     const hasResults = gifs.length;\n    return  <div className=\"page\">\n    <Header clearSearch={this.clearSearch} hasResults={hasResults} />\n\n    <div className=\"search grid\">\n      {/* our stack of gif images */}\n   \n      {/* here we loop over our array of images from our state\n      and we create multiple videos from it. We use map() to go \n      over each one and create multiple components from that */}\n      {this.state.gifs.map (gif=> (\n      //  we spread out all our properties onto our Gif component\n       <Gif {...gif} />\n      ))}\n\n      <input className=\"input grid-item\" placeholder=\"Type somethin\"\n      onChange={this.handleChange}\n      onKeyPress={this.handleKeyPress}\n      value={searchTerm}\n      />\n    </div>\n    {/* here we pass our userHint all of our state usnig a spread */}\n    < UserHint {...this.state}/>\n  </div>\n  };\n}\n\n\nexport default App;\n"]},"metadata":{},"sourceType":"module"}