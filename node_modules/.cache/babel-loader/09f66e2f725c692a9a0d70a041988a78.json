{"ast":null,"code":"import _regeneratorRuntime from\"/Users/apple/Sites/jiffy/node_modules/@babel/runtime/regenerator\";import _toConsumableArray from\"/Users/apple/Sites/jiffy/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _objectSpread from\"/Users/apple/Sites/jiffy/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _asyncToGenerator from\"/Users/apple/Sites/jiffy/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _classCallCheck from\"/Users/apple/Sites/jiffy/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/Users/apple/Sites/jiffy/node_modules/@babel/runtime/helpers/esm/createClass\";import _createSuper from\"/Users/apple/Sites/jiffy/node_modules/@babel/runtime/helpers/esm/createSuper\";import _inherits from\"/Users/apple/Sites/jiffy/node_modules/@babel/runtime/helpers/esm/inherits\";import React,{Component}from'react';//here we import in our loader spinner image\nimport loader from\"./images/loader.svg\";import clearButton from\"./images/close-icon.svg\";import Gif from'./Gif';var randomChoice=function randomChoice(arr){var randIndex=Math.floor(Math.random()*arr.length);return arr[randIndex];};// we pick out our props inside the header component\n// we can pass down functions as props as well as things\n// like numbers, strings, arrays or objects\nvar Header=function Header(_ref){var clearSearch=_ref.clearSearch,hasResults=_ref.hasResults;return/*#__PURE__*/React.createElement(\"div\",{className:\"header grid\"},hasResults?/*#__PURE__*/React.createElement(\"button\",{onClick:clearSearch},/*#__PURE__*/React.createElement(\"img\",{src:clearButton,alt:\"clear button\"})):/*#__PURE__*/React.createElement(\"h1\",{className:\"title\"},\"Jiffy\"));};var UserHint=function UserHint(_ref2){var loading=_ref2.loading,hintText=_ref2.hintText;return/*#__PURE__*/React.createElement(\"div\",{className:\"user-hint\"},loading?/*#__PURE__*/React.createElement(\"img\",{src:require('./images/loader.svg'),alt:\"loader\",className:\"block mx-auto\"}):hintText);};var App=/*#__PURE__*/function(_Component){_inherits(App,_Component);var _super=_createSuper(App);function App(props){var _this;_classCallCheck(this,App);_this=_super.call(this,props);_this.searchGiphy=/*#__PURE__*/function(){var _ref3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(searchTerm){var response,_yield$response$json,data,randomGif;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_this.setState({//here we set our loading state to be true\n//and this will show the spinner at the bottom\nloading:true});// first we try our fetch\n_context.prev=1;_context.next=4;return fetch(\"https://api.giphy.com/v1/gifs/search?api_key=JWfQkyED854JjZJOKiPMb6BZkrxpam10&q=\".concat(searchTerm,\"&limit=25&offset=0&rating=g&lang=en\"));case 4:response=_context.sent;_context.next=7;return response.json();case 7:_yield$response$json=_context.sent;data=_yield$response$json.data;if(data.length){_context.next=11;break;}throw\"Nothing found for \".concat(searchTerm);case 11:// here we grab a random result from our images\nrandomGif=randomChoice(data);_this.setState(function(prevState,props){return _objectSpread({},prevState,{// get the first result and put it in the state\n// gif: randomGif,\n// here we use spread to take the previous gifs and spread them out\n// and then, add our new random gif onto the end\ngifs:[].concat(_toConsumableArray(prevState.gifs),[randomGif]),//we turn off our loading spinner again\nloading:false,hintText:\"Hit enter to see more \".concat(searchTerm)});});// if our fetch fails we catch it down here\n_context.next=18;break;case 15:_context.prev=15;_context.t0=_context[\"catch\"](1);_this.setState(function(prevState,props){return _objectSpread({},prevState,{hintText:_context.t0,loading:false});});case 18:case\"end\":return _context.stop();}}},_callee,null,[[1,15]]);}));return function(_x){return _ref3.apply(this,arguments);};}();_this.handleChange=function(event){// const value = event.target.value\nvar value=event.target.value;// by setting the searcht term in our state\n// and alos using that on the input as the value,\n// we have created what is called a controlled input\n_this.setState(function(prevState,props){return _objectSpread({},prevState,{//and then we overwrite the ones we want after\nsearchTerm:value,// we set the hint text when we have more than two characters\n// in our input, otherwise we make it a empty string\nhintText:value.length>2?\"Hit enter to search \".concat(value):''});});};_this.handleKeyPress=function(event){// when we have two or more characters in our search box\n// and we have also pressed enter, we then want to run a search\n// we can access a function called key\nvar value=event.target.value;if(value.length>2&&event.key==='Enter'){//here is where we run our search function\n//here we call our searchGiphy function using the search term\n_this.searchGiphy(value);}};_this.clearSearch=function(){_this.setState(function(prevState,props){return _objectSpread({},prevState,{searchTerm:'',hintText:'',gifs:[]});});// here we grab the input and then focus the cursor back into it\n_this.textInput.current.focus();};_this.textInput=React.createRef();_this.state={loading:false,searchTerm:'',hintText:'',// gif: null,\n// we have an array of gifs\ngifs:[]};return _this;}// we want a function that searches the giphy api using\n// fetch and puts the search term into the query URL\n// then we can do something with the results\n// we can also write async methods into our components\n// that let us use the async/await style of function\n_createClass(App,[{key:\"render\",value:function render(){//const searchTerm = this.state.searchTerm\nvar _this$state=this.state,searchTerm=_this$state.searchTerm,gifs=_this$state.gifs;//here we set a variable to see if we have any gifs\nvar hasResults=gifs.length;return/*#__PURE__*/React.createElement(\"div\",{className:\"page\"},/*#__PURE__*/React.createElement(Header,{clearSearch:this.clearSearch,hasResults:hasResults}),/*#__PURE__*/React.createElement(\"div\",{className:\"search grid\"},this.state.gifs.map(function(gif){return/*#__PURE__*/ //  we spread out all our properties onto our Gif component\nReact.createElement(Gif,gif);}),/*#__PURE__*/React.createElement(\"input\",{className:\"input grid-item\",placeholder:\"Type somethin\",onChange:this.handleChange,onKeyPress:this.handleKeyPress,value:searchTerm,ref:this.textInput})),/*#__PURE__*/React.createElement(UserHint,this.state));}}]);return App;}(Component);export default App;","map":{"version":3,"sources":["/Users/apple/Sites/jiffy/src/App.js"],"names":["React","Component","Gif","randomChoice","arr","randIndex","Math","floor","random","length","Header","clearSearch","hasResults","clearButton","UserHint","loading","hintText","require","App","props","searchGiphy","searchTerm","setState","fetch","response","json","data","randomGif","prevState","gifs","handleChange","event","value","target","handleKeyPress","key","textInput","current","focus","createRef","state","map","gif"],"mappings":"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","sourcesContent":["import React, {Component} from 'react';\n//here we import in our loader spinner image\nimport loader from './images/loader.svg';\n\nimport clearButton from './images/close-icon.svg';\n\nimport Gif from './Gif';\n\n\nconst randomChoice = arr => {\n  const randIndex = Math.floor(Math.random()* arr.length);\n  return arr[randIndex];\n};\n\n// we pick out our props inside the header component\n// we can pass down functions as props as well as things\n// like numbers, strings, arrays or objects\n\nconst Header = ({clearSearch, hasResults}) => (\n  <div className=\"header grid\">\n    {/* if we have results, show the clear button, otherwise show the title */}\n    { hasResults ? (\n      <button onClick={clearSearch}>\n        <img src={clearButton} alt=\"clear button\" />\n      </button>\n    ) : (<h1 className=\"title\">Jiffy</h1>)}\n  </div>\n);\n\nconst UserHint = ({loading, hintText}) => (\n  <div className=\"user-hint\"> \n  {/* here we check whether we have a loading state and we render out\n  either our spinner or hintText based on that, using a ternary operator */}\n  {loading ? \n  <img src={require('./images/loader.svg')} alt=\"loader\" className=\"block mx-auto\" /> :\n    hintText\n  }</div>\n);\n\nclass App extends Component {\nconstructor(props) {\n  super(props); \n  this.textInput = React.createRef();\n  this.state = {\n    loading: false,\n    searchTerm: '',\n    hintText: '',\n    // gif: null,\n    // we have an array of gifs\n    gifs: []\n  }\n}\n\n// we want a function that searches the giphy api using\n// fetch and puts the search term into the query URL\n// then we can do something with the results\n\n// we can also write async methods into our components\n// that let us use the async/await style of function\nsearchGiphy = async searchTerm => {\n\n  this.setState ({\n    //here we set our loading state to be true\n    //and this will show the spinner at the bottom\n    loading : true\n  });\n  // first we try our fetch\n  try {\n    // here we use the await key word to wait for our response to come back\n    const response = await fetch(\n      `https://api.giphy.com/v1/gifs/search?api_key=JWfQkyED854JjZJOKiPMb6BZkrxpam10&q=${searchTerm}&limit=25&offset=0&rating=g&lang=en`\n      ); \n    \n     // here we convert our raw response into jason data \n    // const {data} gets the .data part of our responses\n     const {data} = await response.json();\n\n\n    // here we check if the array of results is empty\n    // if it is, we throw an error which will stop the\n    // code here and handle it in the catch area\n\n    if (!data.length) {\n      throw `Nothing found for ${searchTerm}`\n    }\n\n\n      \n    // here we grab a random result from our images\n    const randomGif = randomChoice(data)\n\n\n    this.setState((prevState, props) => ({\n      ...prevState,\n      // get the first result and put it in the state\n      // gif: randomGif,\n      // here we use spread to take the previous gifs and spread them out\n      // and then, add our new random gif onto the end\n      gifs: [...prevState.gifs, randomGif ],\n      //we turn off our loading spinner again\n      loading: false, \n      hintText: `Hit enter to see more ${searchTerm}`\n    }))\n    \n    // if our fetch fails we catch it down here\n    } catch (error) {\n      this.setState((prevState, props) => ({\n        ...prevState,\n        hintText:error,\n        loading:false\n      }))\n    }\n  };\n\n  //with create react app we can write our methods as arrow\n  //functions, meaning we don't need the constructor and bind\n  handleChange = event => {\n    // const value = event.target.value\n    const {value} = event.target;\n    // by setting the searcht term in our state\n    // and alos using that on the input as the value,\n    // we have created what is called a controlled input\n    this.setState((prevState, props) => ({\n      //we take our old props and spread them out here\n      ...prevState,\n      //and then we overwrite the ones we want after\n      searchTerm: value,\n      // we set the hint text when we have more than two characters\n      // in our input, otherwise we make it a empty string\n      hintText: value.length > 2 ? `Hit enter to search ${value}` : ''\n    }));\n    \n   };\n    \n   handleKeyPress = event => {\n   // when we have two or more characters in our search box\n   // and we have also pressed enter, we then want to run a search\n   // we can access a function called key\n    const {value} = event.target;\n    if (value.length > 2 && event.key === 'Enter') {\n      //here is where we run our search function\n      //here we call our searchGiphy function using the search term\n      this.searchGiphy(value);\n    }\n   };\n\n   // here we reset our state by clearing every out and\n   // making it default again (like in our original state)\n   clearSearch = () => {\n     this.setState((prevState, props) => \n     ({\n       ...prevState,\n       searchTerm:'',\n       hintText: '',\n       gifs: []\n     }));\n     // here we grab the input and then focus the cursor back into it\n    this.textInput.current.focus();\n   };\n\n   render() {\n     //const searchTerm = this.state.searchTerm\n     const { searchTerm, gifs } = this.state\n     //here we set a variable to see if we have any gifs\n     const hasResults = gifs.length;\n    return  <div className=\"page\">\n    <Header clearSearch={this.clearSearch} hasResults={hasResults} />\n\n    <div className=\"search grid\">\n      {/* our stack of gif images */}\n   \n      {/* here we loop over our array of images from our state\n      and we create multiple videos from it. We use map() to go \n      over each one and create multiple components from that */}\n      {this.state.gifs.map (gif=> (\n      //  we spread out all our properties onto our Gif component\n       <Gif {...gif} />\n      ))}\n\n      <input className=\"input grid-item\" placeholder=\"Type somethin\"\n      onChange={this.handleChange}\n      onKeyPress={this.handleKeyPress}\n      value={searchTerm}\n      ref={this.textInput}\n      />\n    </div>\n    {/* here we pass our userHint all of our state usnig a spread */}\n    < UserHint {...this.state}/>\n  </div>\n  };\n}\n\n\nexport default App;\n"]},"metadata":{},"sourceType":"module"}