{"version":3,"sources":["images/close-icon.svg","App.js","Gif.js","serviceWorker.js","index.js","images/loader.svg"],"names":["module","exports","Header","Component","clearSearch","hasResults","className","onClick","src","clearButton","alt","UserHint","loading","hintText","require","App","props","searchGiphy","searchTerm","a","setState","fetch","response","json","data","length","randomGif","arr","Math","floor","random","prevState","gifs","handleChange","event","value","target","handleKeyPress","key","textInput","current","focus","React","createRef","state","this","map","gif","placeholder","onChange","onKeyPress","ref","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"kFAAAA,EAAOC,QAAU,IAA0B,wC,uOCkBrCC,GChBYC,YDgBH,SAAC,GAAD,IAAEC,EAAF,EAAEA,YAAaC,EAAf,EAAeA,WAAf,OACb,yBAAKC,UAAU,eAEXD,EACA,4BAAQE,QAASH,GACf,yBAAKI,IAAKC,IAAaC,IAAI,kBAE1B,wBAAIJ,UAAU,SAAd,YAIHK,EAAW,SAAC,GAAD,IAAEC,EAAF,EAAEA,QAASC,EAAX,EAAWA,SAAX,OACf,yBAAKP,UAAU,aAGdM,EACD,yBAAKJ,IAAKM,EAAQ,GAAwBJ,IAAI,SAASJ,UAAU,kBAC/DO,IA8JWE,E,kDAzJf,WAAYC,GAAQ,IAAD,8BACjB,cAAMA,IAkBRC,YAnBmB,uCAmBL,WAAMC,GAAN,qBAAAC,EAAA,6DAEZ,EAAKC,SAAU,CAGbR,SAAU,IALA,kBAUaS,MAAM,mFAAD,OACyDH,EADzD,wCAVlB,cAUJI,EAVI,gBAgBYA,EAASC,OAhBrB,oBAgBFC,EAhBE,EAgBFA,MAOEC,OAvBA,kDAwBmBP,GAxBnB,QA8BJQ,GAhFWC,EAgFcH,GA/EfI,KAAKC,MAAMD,KAAKE,SAAUH,EAAIF,SAkF9C,EAAKL,UAAS,SAACW,EAAWf,GAAZ,sBACTe,EADS,CAMZC,KAAK,GAAD,mBAAMD,EAAUC,MAAhB,CAAsBN,IAE1Bd,SAAS,EACTC,SAAS,yBAAD,OAA2BK,QA1C3B,kDA+CR,EAAKE,UAAS,SAACW,EAAWf,GAAZ,sBACTe,EADS,CAEZlB,SAAS,EAAD,GACRD,SAAQ,OAlDF,kCAlDO,IAAAe,IAkDP,qBAnBK,wDA4EjBM,aAAe,SAAAC,GAAS,IAEfC,EAASD,EAAME,OAAfD,MAIP,EAAKf,UAAS,SAACW,EAAWf,GAAZ,sBAETe,EAFS,CAIZb,WAAYiB,EAGZtB,SAAUsB,EAAMV,OAAS,EAAf,8BAA0CU,GAAU,SAzFjD,EA8FhBE,eAAiB,SAAAH,GAAS,IAIlBC,EAASD,EAAME,OAAfD,MACHA,EAAMV,OAAS,GAAmB,UAAdS,EAAMI,KAG5B,EAAKrB,YAAYkB,IAtGJ,EA4GhB/B,YAAc,WACZ,EAAKgB,UAAS,SAACW,EAAWf,GAAZ,sBAETe,EAFS,CAGZb,WAAW,GACXL,SAAU,GACVmB,KAAM,QAGT,EAAKO,UAAUC,QAAQC,SAnHzB,EAAKF,UAAYG,IAAMC,YACvB,EAAKC,MAAQ,CACXhC,SAAS,EACTM,WAAY,GACZL,SAAU,GAGVmB,KAAM,IATS,E,qDAwHP,MAEsBa,KAAKD,MAA1B1B,EAFD,EAECA,WAEFb,EAJC,EAEa2B,KAEIP,OACzB,OAAQ,yBAAKnB,UAAU,QACvB,kBAAC,EAAD,CAAQF,YAAayC,KAAKzC,YAAaC,WAAYA,IAEnD,yBAAKC,UAAU,eAMZuC,KAAKD,MAAMZ,KAAKc,KAAK,SAAAC,OAKtB,2BAAOzC,UAAU,kBAAkB0C,YAAY,gBAC/CC,SAAUJ,KAAKZ,aACfiB,WAAYL,KAAKR,eACjBF,MAAOjB,EACPiC,IAAKN,KAAKN,aAIZ,kBAAE,EAAaM,KAAKD,Y,GApJNzC,aE3BEiD,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SDyHpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAME,a,kBEzI5BvE,EAAOC,QAAU,IAA0B,qC","file":"static/js/main.326542ec.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/close-icon.5b9a3ae1.svg\";","import React, {Component} from 'react';\n//here we import in our loader spinner image\nimport loader from './images/loader.svg';\n\nimport clearButton from './images/close-icon.svg';\n\nimport Gif from './Gif';\n\n\nconst randomChoice = arr => {\n  const randIndex = Math.floor(Math.random()* arr.length);\n  return arr[randIndex];\n};\n\n// we pick out our props inside the header component\n// we can pass down functions as props as well as things\n// like numbers, strings, arrays or objects\n\nconst Header = ({clearSearch, hasResults}) => (\n  <div className=\"header grid\">\n    {/* if we have results, show the clear button, otherwise show the title */}\n    { hasResults ? (\n      <button onClick={clearSearch}>\n        <img src={clearButton} alt=\"clear button\" />\n      </button>\n    ) : (<h1 className=\"title\">Jiffy</h1>)}\n  </div>\n);\n\nconst UserHint = ({loading, hintText}) => (\n  <div className=\"user-hint\"> \n  {/* here we check whether we have a loading state and we render out\n  either our spinner or hintText based on that, using a ternary operator */}\n  {loading ? \n  <img src={require('./images/loader.svg')} alt=\"loader\" className=\"block mx-auto\" /> :\n    hintText\n  }</div>\n);\n\nclass App extends Component {\nconstructor(props) {\n  super(props); \n  this.textInput = React.createRef();\n  this.state = {\n    loading: false,\n    searchTerm: '',\n    hintText: '',\n    // gif: null,\n    // we have an array of gifs\n    gifs: []\n  }\n}\n\n// we want a function that searches the giphy api using\n// fetch and puts the search term into the query URL\n// then we can do something with the results\n\n// we can also write async methods into our components\n// that let us use the async/await style of function\nsearchGiphy = async searchTerm => {\n\n  this.setState ({\n    //here we set our loading state to be true\n    //and this will show the spinner at the bottom\n    loading : true\n  });\n  // first we try our fetch\n  try {\n    // here we use the await key word to wait for our response to come back\n    const response = await fetch(\n      `https://api.giphy.com/v1/gifs/search?api_key=JWfQkyED854JjZJOKiPMb6BZkrxpam10&q=${searchTerm}&limit=25&offset=0&rating=g&lang=en`\n      ); \n    \n     // here we convert our raw response into jason data \n    // const {data} gets the .data part of our responses\n     const {data} = await response.json();\n\n\n    // here we check if the array of results is empty\n    // if it is, we throw an error which will stop the\n    // code here and handle it in the catch area\n\n    if (!data.length) {\n      throw `Nothing found for ${searchTerm}`\n    }\n\n\n      \n    // here we grab a random result from our images\n    const randomGif = randomChoice(data)\n\n\n    this.setState((prevState, props) => ({\n      ...prevState,\n      // get the first result and put it in the state\n      // gif: randomGif,\n      // here we use spread to take the previous gifs and spread them out\n      // and then, add our new random gif onto the end\n      gifs: [...prevState.gifs, randomGif ],\n      //we turn off our loading spinner again\n      loading: false, \n      hintText: `Hit enter to see more ${searchTerm}`\n    }))\n    \n    // if our fetch fails we catch it down here\n    } catch (error) {\n      this.setState((prevState, props) => ({\n        ...prevState,\n        hintText:error,\n        loading:false\n      }))\n    }\n  };\n\n  //with create react app we can write our methods as arrow\n  //functions, meaning we don't need the constructor and bind\n  handleChange = event => {\n    // const value = event.target.value\n    const {value} = event.target;\n    // by setting the searcht term in our state\n    // and alos using that on the input as the value,\n    // we have created what is called a controlled input\n    this.setState((prevState, props) => ({\n      //we take our old props and spread them out here\n      ...prevState,\n      //and then we overwrite the ones we want after\n      searchTerm: value,\n      // we set the hint text when we have more than two characters\n      // in our input, otherwise we make it a empty string\n      hintText: value.length > 2 ? `Hit enter to search ${value}` : ''\n    }));\n    \n   };\n    \n   handleKeyPress = event => {\n   // when we have two or more characters in our search box\n   // and we have also pressed enter, we then want to run a search\n   // we can access a function called key\n    const {value} = event.target;\n    if (value.length > 2 && event.key === 'Enter') {\n      //here is where we run our search function\n      //here we call our searchGiphy function using the search term\n      this.searchGiphy(value);\n    }\n   };\n\n   // here we reset our state by clearing every out and\n   // making it default again (like in our original state)\n   clearSearch = () => {\n     this.setState((prevState, props) => \n     ({\n       ...prevState,\n       searchTerm:'',\n       hintText: '',\n       gifs: []\n     }));\n     // here we grab the input and then focus the cursor back into it\n    this.textInput.current.focus();\n   };\n\n   render() {\n     //const searchTerm = this.state.searchTerm\n     const { searchTerm, gifs } = this.state\n     //here we set a variable to see if we have any gifs\n     const hasResults = gifs.length;\n    return  <div className=\"page\">\n    <Header clearSearch={this.clearSearch} hasResults={hasResults} />\n\n    <div className=\"search grid\">\n      {/* our stack of gif images */}\n   \n      {/* here we loop over our array of images from our state\n      and we create multiple videos from it. We use map() to go \n      over each one and create multiple components from that */}\n      {this.state.gifs.map (gif=> (\n      //  we spread out all our properties onto our Gif component\n       <Gif {...gif} />\n      ))}\n\n      <input className=\"input grid-item\" placeholder=\"Type somethin\"\n      onChange={this.handleChange}\n      onKeyPress={this.handleKeyPress}\n      value={searchTerm}\n      ref={this.textInput}\n      />\n    </div>\n    {/* here we pass our userHint all of our state usnig a spread */}\n    < UserHint {...this.state}/>\n  </div>\n  };\n}\n\n\nexport default App;\n","import React, {Component} from 'react';\n\nclass Gif extends Component {\n\n    // when our video has loaded we add a load classname\n    // otherwise the video stays hidden\n    constructor(props) {\n        super(props)\n        this.state = {\n            loaded: false\n        }\n    }\n\n\n    render() {\n        const {loaded} = this.state;\n        const {images} = this.props;\n        return(\n            <video\n            // when we have the loaded state as true, we add a loaded class\n          className= {`grid-item video  ${loaded && 'loaded'}`}\n          autoPlay\n          loop\n          src={images.original.mp4}\n          // when the video loads we set the loaded state to be true\n          onLoadedData={() => this.setState({loaded: true}) }\n        />\n        )\n    }\n}\n\nexport default Gif;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './css/main.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","module.exports = __webpack_public_path__ + \"static/media/loader.be00fc4a.svg\";"],"sourceRoot":""}